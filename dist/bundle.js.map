{"version":3,"file":"bundle.js","sources":["../node_modules/@hyperapp/router/src/parseRoute.js","../node_modules/@hyperapp/router/src/location.js","../node_modules/@hyperconnect/client/src/ws.js"],"sourcesContent":["function createMatch(isExact, path, url, params) {\n  return {\n    isExact: isExact,\n    path: path,\n    url: url,\n    params: params\n  }\n}\n\nfunction trimTrailingSlash(url) {\n  for (var len = url.length; \"/\" === url[--len]; );\n  return url.slice(0, len + 1)\n}\n\nfunction decodeParam(val) {\n  try {\n    return decodeURIComponent(val)\n  } catch (e) {\n    return val\n  }\n}\n\nexport function parseRoute(path, url, options) {\n  if (path === url || !path) {\n    return createMatch(path === url, path, url)\n  }\n\n  var exact = options && options.exact\n  var paths = trimTrailingSlash(path).split(\"/\")\n  var urls = trimTrailingSlash(url).split(\"/\")\n\n  if (paths.length > urls.length || (exact && paths.length < urls.length)) {\n    return\n  }\n\n  for (var i = 0, params = {}, len = paths.length, url = \"\"; i < len; i++) {\n    if (\":\" === paths[i][0]) {\n      params[paths[i].slice(1)] = urls[i] = decodeParam(urls[i])\n    } else if (paths[i] !== urls[i]) {\n      return\n    }\n    url += urls[i] + \"/\"\n  }\n\n  return createMatch(false, path, url.slice(0, -1), params)\n}\n","function wrapHistory(keys) {\n  return keys.reduce(function(next, key) {\n    var fn = history[key]\n\n    history[key] = function(data, title, url) {\n      fn.call(this, data, title, url)\n      dispatchEvent(new CustomEvent(\"pushstate\", { detail: data }))\n    }\n\n    return function() {\n      history[key] = fn\n      next && next()\n    }\n  }, null)\n}\n\nexport var location = {\n  state: {\n    pathname: window.location.pathname,\n    previous: window.location.pathname\n  },\n  actions: {\n    go: function(pathname) {\n      history.pushState(null, \"\", pathname)\n    },\n    set: function(data) {\n      return data\n    }\n  },\n  subscribe: function(actions) {\n    function handleLocationChange(e) {\n      actions.set({\n        pathname: window.location.pathname,\n        previous: e.detail\n          ? (window.location.previous = e.detail)\n          : window.location.previous\n      })\n    }\n\n    var unwrap = wrapHistory([\"pushState\", \"replaceState\"])\n\n    addEventListener(\"pushstate\", handleLocationChange)\n    addEventListener(\"popstate\", handleLocationChange)\n\n    return function() {\n      removeEventListener(\"pushstate\", handleLocationChange)\n      removeEventListener(\"popstate\", handleLocationChange)\n      unwrap()\n    }\n  }\n}\n","let ws = undefined\n\nexport const cache = []\nexport let open = false\nexport let apiVersion = \"v0\"\n\nlet error = (...msg) => console.error(...msg)\n\nconst isString = o => typeof o === \"string\"\nconst isFunction = o => typeof o === \"function\"\n\nconst stringify = msg => {\n  try {\n    if (isString(msg)) {\n      msg = JSON.parse(msg)\n    }\n\n    msg[0] = `${apiVersion}.${msg[0]}`\n\n    return JSON.stringify(msg)\n  } catch (e) {\n    error(e)\n  }\n}\n\nconst parse = msg => {\n  if (!isString(msg)) {\n    return msg\n  }\n\n  try {\n    return JSON.parse(msg)\n  } catch (e) {\n    return msg\n  }\n}\n\nconst reactions = actions => ({\n  onmessage: e => {\n    if (e.data === \"Unknown Action\") {\n      error(\"Unknown Action\", e)\n      return\n    }\n\n    const [path, data] = parse(e.data)\n    let action = actions\n\n    path.split(\".\").forEach(key => {\n      const fnName = `${key}_done`\n      const sub = action[fnName]\n      if (isFunction(sub)) {\n        action = sub\n      } else {\n        action = action[key]\n      }\n    })\n\n    if (isFunction(action)) {\n      return action(data)\n    }\n  },\n  open: () => {\n    open = true\n\n    while (cache.length) {\n      const msg = cache.shift()\n      ws.send(stringify(msg))\n    }\n  },\n  close: () => {\n    open = false\n  }\n})\n\nexport const connect = (actions, options = {}) => {\n  const host = options.host || location.hostname\n  const port = options.port || location.port\n  const protocol = options.protocol || \"ws\"\n\n  apiVersion = options.apiVersion || \"v0\"\n  error = options.error || error\n\n  if (!ws) {\n    ws = new WebSocket(`${protocol}://${host}:${port}`)\n    open = false\n  }\n\n  const react = reactions(actions)\n\n  ws.onopen = react.open\n  ws.onclose = react.close\n  ws.onmessage = react.onmessage\n\n  return ws\n}\n\nexport const send = msg => {\n  if (open) {\n    ws.send(stringify(msg))\n  } else {\n    cache.push(msg)\n  }\n}\n\nexport default connect\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ECAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ECAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;"}